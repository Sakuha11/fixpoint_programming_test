# プログラムの内容説明

## ファイル構成
たとえば設問１に関連するファイルは以下の通り。
- `Q1.cpp`：設問１で要求される処理を実行するためのスクリプト（設問１の解答）
- `Q1_in.txt`：設問１のテスト入力
- `Q1_out.txt`：設問１のテスト出力

設問２～４についても同様。
また`create_test_data.cpp`はテスト用のデータを生成するためのスクリプト。

<br>

## プログラムの実行方法
たとえば設問１では、`Q1.cpp`をコンパイルして実行することで、スクリプト内で指定された監視ログファイル`Q1_in.txt`が自動的に読み込まれて処理される。
処理結果は`Q1_out.txt`に書き込まれる。
他の設問についても同様の手順でプログラムを実行する。

<br>

## 設問１の解答説明
まず11行目（以下、行番号はL11のように表記）で「故障したサーバのIPアドレスとタイムアウトした日時」を格納するための変数を定義する。
```cpp
map<string, string> failureLogs;
```
これは連想配列であり、故障中のサーバのIPアドレスをキーとして、そのサーバーが最初にタイムアウトした時間を記録する。  
この変数定義を行った後、続く2行で入力ファイルおよび出力ファイルを指定する。

以降では監視ログファイルの入力と並行して、設問１の要件「故障状態のサーバアドレスとそのサーバの故障期間の出力」を満たす処理を行う。  
まず処理手順の概要を以下に示す。
このとき「故障状態」が「pingが過去にタイムアウトして、かつそれ以降で該当サーバから応答確認が取れていない状態」であることに注意する。
1. 監視ログファイルから1行読み込み、応答確認結果を取得する。
2. 応答の有無に応じて以下の処理を行う。
   - 応答が無かった場合：これが最初のタイムアウトだった場合、サーバのIPアドレスと時間を記録する。
   - 応答が有った場合：この応答確認で故障状態からの回復が確かめられた場合、サーバの故障期間を出力する。
3. 手順1,2を繰り返す。

次に手順1,2とスクリプトの対応について具体的に述べる。

### 手順1：データの取得
L17~21で以下のようにデータの取得を行う。
```cpp
string dateTime, IPaddress, ping;
istringstream logDataStream(logData);
getline(logDataStream, dateTime, ',');
getline(logDataStream, IPaddress, ',');
getline(logDataStream, ping, ',');
```
`logData`には監視ログファイルの1行分のデータが文字列として格納されている。
この中には「応答確認日時」「サーバのIPアドレス」「応答結果」がカンマ区切りで含まれているので、これらを分離してそれぞれ変数`dateTime`、`IPaddress`、`ping`に格納する。

### 手順2：故障状態の記録
今注目しているのはサーバの故障期間、すなわち「最初にタイムアウトした日時」と「故障状態から応答が回復した日時」であるため、サーバの状態が「正常→故障」または「故障→正常」に変化したタイミングで記録する必要があることに注意する。

まず応答が無かった場合について述べる。
このときL24の以下のif文が実行される。
```cpp
if (!failureLogs.count(IPaddress)) failureLogs[IPaddress] = dateTime;
```
上記のコードで示されるif文の条件式では、「応答確認を行う前に該当サーバがすでに故障状態にあったか否か」を判定し、確認前では故障状態でなかった場合に処理を実行している。
ここで条件式について、`failureLogs`には故障中のサーバの情報のみ記録されるので、「この配列に該当サーバが含まれているか否か」で「故障状態にあったか否か」を判定している。  
故障状態でなかった場合、すなわちサーバの状態が「正常→故障」に変化した場合に、`failureLogs`にタイムアウトした日時とともにサーバの故障を記録する。

次に応答が有った場合に実行される、L26~29のif文について述べる。
```cpp
if (failureLogs.count(IPaddress)) {
    fout << failureLogs[IPaddress] << ',' << dateTime << ',' << IPaddress << endl;
    failureLogs.erase(IPaddress);
}
```
手順2の説明の冒頭で述べたように、処理を行うタイミングはサーバの状態が「正常→故障」または「故障→正常」に変化したときである。
「正常→故障」の変化についてはすでに考えたので、ここでは「故障→正常」に変化したときを考えれば良い。  
上記のコードでは、処理を実行するタイミングを「サーバが故障状態から回復したとき」に限定するため、まずif文の条件式で「応答確認前にサーバが故障状態にあったか否か」を判定している。
サーバが故障状態から回復した場合は、この時点でサーバの故障期間が確定するため、これをif文の中の実行文で出力している。  
またL28でサーバの情報を`failureLogs`から削除しているが、これはサーバが回復した時点で故障状態でなくなり、「故障中のサーバ」の情報を格納する`failureLogs`に含めるのは不適となるためである。

最後に、サーバが故障状態となった後に応答が回復しなかったものについてL32で出力している。
```cpp
for (auto p : failureLogs) fout << p.second << ",-," << p.first << endl;
```
L32までに監視ログファイルの読み込みは完了しており、応答が回復したものは`failureLogs`から削除されているため、これらの処理を経てなお`failureLogs`に含まれているものが「故障状態となったまま応答が回復しなかったサーバ」である。
このようなサーバの故障期間の終端は未定であるため、これを`"-"`で表している。

### 出力ファイルのフォーマット
サーバの故障期間の出力形式はL27に示されるように、「サーバが最初にタイムアウトした日時」「故障状態にあったサーバの回復が確認された日時」「該当サーバのIPアドレス」をカンマ区切りで並べたものである。
出力は監視ログファイルの入力を行いつつ、故障期間が確定した時点で都度行っているため、故障期間の並び順は「回復が確認された日時」に関して昇順となっている。

例：
```
20230110123440,20230110123710,192.168.2.5/24
20230110123650,20230110123730,192.168.2.3/24
20230110123640,20230110123750,192.168.5.3/24
...
```
<br>

## 設問２の解答説明
まずL14で、準故障状態にあるサーバを記録する連想配列`failureLogs`を定義する。
ここで準故障状態とは「pingが過去に1回以上`N`回未満連続でタイムアウトして、かつそれ以降で該当サーバから応答確認が取れていない状態」である。
連想配列の値は、設問１では「最初にタイムアウトした日時」を記録していたが、設問２では「連続してタイムアウトした回数」も考慮する必要があるため、記録する値を次のように場合分けする。
- 連続してタイムアウトした回数nが`N`回未満：nを記録
- 連続してタイムアウトした回数nが`N`回以上：n=`N`となったときの日時、すなわちサーバが故障状態となった日時を記録

値がどちらの場合で記録されているか、すなわちサーバが準故障状態か故障状態かの判定には、日時の形式が文字数固定の文字列であることを利用する。
値の文字数が日時の文字数`dateTimeLength`と一致しているとき、サーバが故障状態となった日時が記録されていると判断する。
この判定処理はL15~17に示されるような関数`hasFailure`で記述され、以降の判定にはこの関数を利用する。
```cpp
auto hasFailure = [&](string address) {
    return failureLogs[address].length() == dateTimeLength;
};
```
なお`N`の桁数が`dateTimeLength`と等しいとき判定処理は正しく機能しないが、今`dateTimeLength`は14であり`N`の桁数よりも十分大きいのでこの影響は考慮しなくて良い。

設問１と同様にL19~20で入力ファイルおよび出力ファイルを指定した後、監視ログファイルの入力と並行して「故障状態のサーバアドレスとそのサーバの故障期間の出力」を行う。
ただし「故障状態」の定義が設問１と異なり、「pingが過去に`N`回以上連続でタイムアウトして、かつそれ以降で該当サーバから応答確認が取れていない状態」であることに注意する。  
このとき処理手順を次のように定める。
1. 監視ログファイルから1行読み込み、応答確認結果を取得する。
2. 応答の有無に応じて以下の処理を行う。
   - 応答が無かった場合：連続してタイムアウトした回数をカウントする。
   - 応答が有った場合：この応答確認で故障状態からの回復が確かめられた場合、サーバの故障期間を出力する。
3. 手順1,2を繰り返す。

手順1は設問１のときと同様なので、ここでは手順2について具体的に述べる。

### 手順2：故障状態の記録
設問１と同様、注目しているのはサーバの故障期間すなわち「サーバが故障状態になった日時」と「故障状態から応答が回復した日時」である。
言い換えればサーバの状態が「準故障→故障」または「故障→正常」に変化したタイミングで記録を行う必要があるので、以下ではこれに注意して処理を場合分けする。
ここでサーバの状態の変化について、今定義している状態は「正常」「準故障」「故障」の3種類だが、故障状態に移行するときは必ず準故障状態を経由し、一方で故障状態から応答が回復するときは、タイムアウトした回数がリセットされることから準故障状態を経由しないため、注目する状態変化は「準故障→故障」「故障→正常」の2つである。

#### 応答が無かった場合
このとき「連続してタイムアウトした回数」は必ず増加するため、サーバの状態の変化として考え得るものは
1. 正常→準故障
2. 準故障→準故障
3. 準故障→故障
4. 故障→故障

の4つである。 

「1. 正常→準故障」の場合に属するか否かは、正常状態が「準故障状態でも故障状態でもない」すなわち「サーバが`failureLogs`に含まれない」ことと等価なことから判定できる。
この判定はL31の条件式で行われ、「1. 正常→準故障」の場合に属するときはL32の値更新が実行される。
```cpp
failureLogs[IPaddress] = (N == 1 ? dateTime : "1");
```
正常→準故障に変化したときは、連続タイムアウト数は1であるので、これが上記のコードのように`failureLogs`へ記録される。
ただし`N`=1の場合は準故障状態が存在しない、すなわち設問１と同じ状況のため、`failureLogs`にはタイムアウトした日時が記録される。

「2. 準故障→準故障」あるいは「3. 準故障→故障」に属するか判定するには、『「1. 正常→準故障」でない、かつ応答確認前に故障状態でない』か否かを確かめればよい。
これはL33の条件式で判定されている。
「2. 準故障→準故障」あるいは「3. 準故障→故障」に属する場合、L34のように連続タイムアウト数をカウントアップする。
```cpp
int cntTimeout = stoi(failureLogs[IPaddress]) + 1;
```
次にL35で、「2. 準故障→準故障」と「3. 準故障→故障」のどちらに属すかによって異なる処理を行う。
ここでどちらに属すかの判定をするには、今回のタイムアウトで連続タイムアウト数`cntTimeout`が`N`に達したか否かを確かめれば良い。
```cpp
failureLogs[IPaddress] = (cntTimeout == N ? dateTime : to_string(cntTimeout));
```
`cntTimeout`が`N`に達したとき、すなわち「3. 準故障→故障」の場合、`failureLogs`にはこのときの日時を記録する。
そうでない場合は`failureLogs`に元々記録されていた連続タイムアウト数を1増やす、すなわち`cntTimeout`に更新する。

以上のいずれでもない場合が「4. 故障→故障」であるが、このとき`failureLogs`の値更新は必要ない。

#### 応答が有った場合
このとき連続タイムアウト数はリセットされるため、サーバの状態の変化として考え得るものは
1. 正常→正常
2. 準故障→正常
3. 故障→正常

の3つである。
このうち「1. 正常→正常」は`failureLogs`に影響を及ぼさないので、それ以外の場合について考える。  
「2. 準故障→正常」あるいは「3. 故障→正常」であること、すなわち「応答確認前に正常状態でない」ことは「サーバが`failureLogs`に含まれる」ことと等価であるので、これを確かめることでL37のように条件を判定できる。
さらに「3. 故障→正常」であった場合、すなわちサーバが故障状態から応答が回復した場合は、サーバの故障期間が確定するのでこれを出力する。
```cpp
if (hasFailure(IPaddress)) {
    fout << failureLogs[IPaddress] << ',' << dateTime << ',' << IPaddress << endl;
}
```
「2. 準故障→正常」あるいは「3. 故障→正常」である場合にはサーバの状態が正常に戻るので、L41のようにサーバの情報を`failureLogs`から削除する必要がある。

#### 応答が回復しなかったサーバ
最後に、設問１と同様にサーバが故障状態となった後に応答が回復しなかったものについてL44~47で出力している。
```cpp
for (auto p : failureLogs) {
    string IPaddress = p.first, dateTime = p.second;
    if (hasFailure(IPaddress)) fout << dateTime << ",-," << IPaddress << endl;
}
```
ここで`failureLogs`には準故障状態も含まれているため、これはL46の条件式により出力から除外した。

### 出力ファイルのフォーマット
サーバの故障期間の出力形式は設問１と同様。

<br>

## 設問３の解答説明
L15,16ではそれぞれ、過負荷状態にあるサーバを記録する連想配列`overloadLogs`、各サーバの直近`m`回のping値を記録する連想配列`pingTimes`を定義している。
```cpp
map<string, string> overloadLogs;
map<string, pair<int, deque<int>>> pingTimes;
```
`overloadLogs`は設問１の`failureLogs`と形式上同様のもので、この配列に対する操作も同様である。
`pingTimes`は各サーバに対して直近`m`回あるいはそれ未満の回数のping値をdequeに格納し、それらの和をintとして保存している。

監視ログの読み込み時に行う処理は、大まかに「ping値の記録」と「過負荷状態の記録」の2つがある。
以下ではこの2つの処理についてそれぞれ述べる。
ただし設問３では、L29で示されるようにタイムアウトしたログを無視する。

### ping値の記録
まず取得したping値を、サーバのping値の和を保存する変数に足し上げ、
```cpp
pingTimes[IPaddress].first += pingInt;
```
さらに各ログのping値を保存する配列に新しく記録する。
```cpp
pingTimes[IPaddress].second.push_front(pingInt);
```
このとき保存しているping値の個数が`m`個を超えた場合には、もっとも古い1つを削除する（L34~37）。
```cpp
if (pingTimes[IPaddress].second.size() > m) {
    pingTimes[IPaddress].first -= pingTimes[IPaddress].second.back();
    pingTimes[IPaddress].second.pop_back();
}
```
if文の中の1行目ではping値の和から削除する分の値を引き、2行目でping値の配列から記録を削除している。

### 過負荷状態の記録
ping値の記録を行った後、記録したping値の個数が`m`個に達していれば、それらの平均値を計算しサーバの負荷を評価する（L39~45）。
```cpp
double pingAvg = 1.0*pingTimes[IPaddress].first/m;
if (pingAvg > t) {
    if (!overloadLogs.count(IPaddress)) overloadLogs[IPaddress] = dateTime;
} else if (overloadLogs.count(IPaddress)) {
    fout << overloadLogs[IPaddress] << ',' << dateTime << ',' << IPaddress << endl;
    overloadLogs.erase(IPaddress);
}
```
ping値の平均が`t`を上回った場合、サーバが過負荷状態にあるとしてこれを記録する（L41）。
記録の仕方は設問１のL24で故障状態を記録したときと同様である。  
また平均ping値が`t`以下であった場合、特にこの時点で過負荷状態が解消された場合の処理がL43~44に示されている。
これは設問１における「サーバが故障状態から回復したときの処理（設問１のL27~28）」と同様である。

最後に過負荷状態が解消されなかったサーバについてL48で出力しているおり、これも設問１と同様。

### 出力ファイルのフォーマット
設問１、２と同様。

<br>

## 設問４の解答説明
設問４の要件を満たすためには、設問２における準故障・故障状態の記録に加えて、「サブネットに属するサーバの内、故障状態にある数」を管理すれば良い。
特に「サブネット内の故障サーバ数」が「サブネット内の全サーバ数」に等しいとき、すなわちサブネット内のすべてのサーバが故障しているとき、サブネットが故障していると判定できる。

この判定を可能にするため、「各サブネットに属するサーバのリスト」である`subnetList`を作る（L54）。
```cpp
map<string, set<string>> subnetList;
```
まずこのリストを埋めるため、監視ログファイルを読み込みサブネットとサーバの主従関係を調べ上げる（L56~64）。
`subnetList`内で各サブネットにサーバを割り振っているのは次のコードである（L63）。
```cpp
subnetList[subnet(IPaddress)].insert(IPaddress);
```
ここで`subnet()`はL16~50で定義される関数であり、サーバのプレフィックス長付きIPアドレスを引数として、そのサーバのサブネットのアドレスを返す。
関数内部ではIPアドレスを32ビットの2進数に変換した後、プレフィックス長に対応するサブネットマスクをかけて得られたサブネットのアドレスを再び10進数に戻して値を返している。

`subnetList`を作成した後、設問２と同様の`failureLogs`と「サブネット内の故障サーバ数」を記録する`subnetFailures`を定義する（L68~69）。
ここで`subnetFailures`は、最初すべてのサーバが正常であることから、各サブネットをキーとした値をすべて0に初期化する（L70）。
```cpp
for (auto p : subnetList) subnetFailures[p.first] = "0";
```
またサーバおよびサブネットの故障状態をそれぞれ判定する関数`hasFailure()`、`subnetHasFailure()`を定義しておく（L71~77）。

ここまでの準備を整えた後、監視ログファイルを改めて読み込み、サブネットの故障の記録を行う。
サーバの故障の記録は設問２と同様なので、以下ではサブネットに関連する操作について述べる。

### サブネットの故障状態の記録
故障状態でないサブネットを「正常」とすると、注目するサブネットの状態の変化は「正常→故障」または「故障→正常」である。
すなわち「サブネット内の故障サーバ数」が「サブネット内の全サーバ数」に等しくなる、あるいはその逆の過程が起こるタイミングでサブネットの故障記録を行う必要があるので、これに注意する。

#### 応答が無かった場合
サーバの状態が「準故障→故障」に変化するとき、サブネットの状態も「正常→故障」に変化し得る。
よってこの場合の処理を、L101~102で行っている。
```cpp
strAddInt(subnetFailures[subnetAdd], 1);
if (subnetHasFailure(subnetAdd)) subnetFailures[subnetAdd] = dateTime;
```
ここで`strAddInt()`は整数値を表す文字列に整数を加算する関数であり、L51で定義されている。
サーバが1つ故障状態となったため、そのサーバが属するサブネットの故障サーバ数をカウントアップし、その結果サブネットが故障状態となった場合に`subnetFailures`に日時を記録する。

#### 応答が有った場合
サーバの状態が「故障→正常」に変化するとき、サブネットの状態も「故障→正常」に変化し得る。
よってこの場合の処理を、L107~112で行っている。
```cpp
if (subnetHasFailure(subnetAdd)) {
    fout << subnetFailures[subnetAdd] << ',' << dateTime << ',' << subnetAdd << endl;
    subnetFailures[subnetAdd] = to_string(subnetList[subnetAdd].size() - 1);
} else {
    strAddInt(subnetFailures[subnetAdd], -1);
}
```
上記のコードの最初の条件式が満たされるとき、サブネットの状態が「故障→正常」に変化しサブネットの故障期間が確定するため、その出力を行っている。
また条件式が満たされるときとそうでないときのいずれにおいても、サブネットに属するサーバの状態が「故障→正常」に変化し故障サーバ数が1減るため、サブネットの故障サーバ数をカウントダウンしている。
